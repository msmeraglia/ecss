use crate::Collection;
use std::{
    any::{type_name, Any},
    collections::{HashMap, HashSet},
};

//TODO Make struct including generational id
pub type Entity = usize;
pub type ComponentIdType = u8;

// TODO:
// pub type EntityIdType = usize;
// #[derive(PartialEq, Eq, PartialOrd, Debug, Clone, Copy, Hash)]
// pub struct Entity {
//     id: u32,
//     generation: u32,
// }

// impl From<Entity> for usize {
//     fn from(entity: Entity) -> Self {
//          entity.id as usize
//     }
// }

#[macro_export]
macro_rules! component_types {
    ($($t:ident),+) => {
        #[derive(Debug)]
        pub enum ComponentType {
            $($t),+
        }
        $(impl Component for $t { //$w -> get where clauses?
            fn get_type_id() -> ComponentIdType {
                ComponentType::$t as ComponentIdType
            }
        })+
    };
}

pub trait Component {
    fn get_type_id() -> ComponentIdType;
}

//Stands for ECS, Stupid.
pub struct ECSS {
    entity_counter: Entity,
    reusable_entities: Vec<Entity>,
    type_map: HashMap<ComponentIdType, Box<dyn Any>>,
    entity_map: HashMap<Entity, HashSet<ComponentIdType>>,
}

//TODO Should allow client code to pass in custom allocators for Vecs once stablized
impl Default for ECSS {
    fn default() -> Self {
        Self {
            entity_counter: std::usize::MAX,
            reusable_entities: Vec::new(),
            type_map: HashMap::new(),
            entity_map: HashMap::new(),
        }
    }
}

impl ECSS {
    fn get_collection<T>(&self) -> &Collection<T>
    where
        T: 'static + Component + Sized,
    {
        let type_id = T::get_type_id();
        if let Some(components) = self.type_map.get(&type_id) {
            return components.downcast_ref::<Collection<T>>().unwrap();
        }
        panic!(
            "The Type: {} has not been registered with this ECSS instance.",
            type_name::<T>()
        );
    }

    fn get_collection_mut<T>(&mut self) -> &mut Collection<T>
    where
        T: 'static + Component + Sized,
    {
        let type_id = T::get_type_id();
        if let Some(components) = self.type_map.get_mut(&type_id) {
            return components.downcast_mut::<Collection<T>>().unwrap();
        }
        panic!(
            "The Type: {} has not been registered with this ECSS instance.",
            type_name::<T>()
        );
    }

    /// Returns all entities that have the specified type
    pub fn entities_by_type<T>(&mut self) -> Vec<Entity>
    where
        T: 'static + Component + Sized,
    {
        let collection = self.get_collection::<T>();
        collection.get_entities()
    }

    // Need to find a safer way to access the enum types generated by macro_rules
    pub fn components(&self, entity: Entity) -> impl Iterator<Item = &u8> {
        self.entity_map.get(&entity).unwrap().into_iter()
    }

    pub fn create_entity(&mut self) -> Entity {
        if !self.reusable_entities.is_empty() {
            return self.reusable_entities.pop().unwrap();
        }
        if self.entity_counter <= 0 {
            panic!("You've reached the max number of entities.");
        }
        let entity_id = self.entity_counter;
        self.entity_counter -= 1;
        self.entity_map.insert(entity_id, HashSet::new());
        entity_id
    }

    // TODO: Return Result<> eventually for safer use, although usage will be more verbose...
    pub fn create<T>(&mut self, entity: Entity, data: T)
    where
        T: 'static + Component + Sized,
    {
        let collection = self.get_collection_mut();
        if !collection.contains(entity) {
            collection.create(entity, data);
            drop(collection);

            let type_list = self.entity_map.get_mut(&entity).unwrap();
            type_list.insert(T::get_type_id());
        }
    }

    pub fn entities_where<T, F>(&self, f: F) -> Vec<Entity>
    where
        T: 'static + Component + Sized,
        F: Fn(&T) -> bool + 'static,
    {
        let collection = self.get_collection();
        collection.entities_where(f)
    }

    pub fn exists<T>(&self, entity: Entity) -> bool
    where
        T: 'static + Component + Sized,
    {
        let collection = self.get_collection::<T>();
        collection.contains(entity)
    }

    pub fn get<T>(&self, entity: Entity) -> Option<&T>
    where
        T: 'static + Component + Sized,
    {
        let collection = self.get_collection();
        collection.get(entity)
    }

    pub fn get_mut<T>(&mut self, entity: Entity) -> Option<&mut T>
    where
        T: 'static + Component + Sized,
    {
        let collection = self.get_collection_mut();
        collection.get_mut(entity)
    }

    pub fn new() -> Self {
        Default::default()
    }

    pub fn iter<T>(&self) -> impl Iterator<Item = &T>
    where
        T: 'static + Component + Sized,
    {
        let collection = self.get_collection();
        collection.iter()
    }

    pub fn iter_mut<T>(&mut self) -> impl Iterator<Item = &mut T>
    where
        T: 'static + Component + Sized,
    {
        let collection = self.get_collection_mut();
        collection.iter_mut()
    }

    pub fn iter_with_entities_mut<T>(&mut self) -> impl Iterator<Item = (Entity, &mut T)>
    where
        T: 'static + Component + Sized,
    {
        let collection = self.get_collection_mut();
        collection.iter_with_entities_mut()
    }
    pub fn iter_with_entities<T>(&self) -> impl Iterator<Item = (Entity, &T)>
    where
        T: 'static + Component + Sized,
    {
        let collection = self.get_collection();
        collection.iter_with_entities()
    }

    // Hmmm, Should this be allowed, due to potential for reallocation?
    pub fn register<T>(&mut self)
    where
        T: 'static + Component + Sized,
    {
        let type_id = T::get_type_id();
        if !self.type_map.contains_key(&type_id) {
            self.type_map
                .insert(type_id, Box::new(Collection::<T>::default()));
        }
    }
    pub fn remove<T>(&mut self, entity: Entity)
    where
        T: 'static + Component + Sized,
    {
        let collection = self.get_collection_mut::<T>();
        collection.remove(entity);
        let type_list = self.entity_map.get_mut(&entity).unwrap();
        type_list.remove(&T::get_type_id());
    }

    pub fn register_sized<T>(&mut self, size: usize)
    where
        T: 'static + Component + Sized,
    {
        let type_id = T::get_type_id();
        if !self.type_map.contains_key(&type_id) {
            self.type_map
                .insert(type_id, Box::new(Collection::<T>::new(size)));
        }
    }
}

#[test]
fn test() {
    component_types!(Position, AttachedTo);

    #[derive(Debug)]
    struct Position {
        test: u32,
    }
    #[derive(Debug)]
    struct AttachedTo {
        attached_to_entity: Entity,
    }

    assert_eq!(Position::get_type_id(), 0);

    let mut ecs = ECSS::new();
    ecs.register_sized::<Position>(4);
    ecs.register_sized::<AttachedTo>(1);

    let entity_0 = ecs.create_entity();
    let entity_1 = ecs.create_entity();
    let entity_2 = ecs.create_entity();
    let entity_3 = ecs.create_entity();
    let entity_4 = ecs.create_entity();

    ecs.create(entity_0, Position { test: 0 });

    ecs.create(entity_1, Position { test: 1 });

    ecs.create(entity_2, Position { test: 2 });

    ecs.create(entity_3, Position { test: 3 });

    ecs.create(entity_4, Position { test: 4 });

    for i in ecs.entities_where(move |e: &Position| e.test == 3) {
        assert!(i == entity_3);
    }

    ecs.create(
        entity_0,
        AttachedTo {
            attached_to_entity: 3,
        },
    );

    for typeid in ecs.components(entity_0) {
        let typename: ComponentType = unsafe { std::mem::transmute(*typeid) };
        println!("{:?}", typename);
    }

    assert!(ecs.exists::<Position>(entity_0));
    assert!(ecs.exists::<Position>(entity_1));
    assert!(ecs.exists::<Position>(entity_2));
    assert!(ecs.exists::<Position>(entity_3));

    assert_eq!(ecs.exists::<Position>(entity_4), false);

    {
        let entity_1_diff_mem: usize = entity_1.clone();
        ecs.remove::<Position>(entity_1_diff_mem);
    }

    assert!(ecs.get::<Position>(entity_1).is_none());

    ecs.remove::<Position>(entity_1);

    if let Some(pos) = ecs.get::<Position>(entity_3) {
        assert_eq!(pos.test, 3);
    } else {
        panic!()
    }

    let mut expected = vec![entity_2, entity_3, entity_0];
    for (entity, _item) in ecs.iter_with_entities::<Position>() {
        assert_eq!(entity, expected.pop().unwrap());
    }

    let mut expected = vec![entity_0, entity_2, entity_3];
    let mut entities = ecs.entities_by_type::<Position>();
    entities.sort();
    for entity in entities {
        assert_eq!(entity, expected.pop().unwrap())
    }

    ecs.create(entity_4, Position { test: 0 });

    assert!(ecs.exists::<Position>(entity_4));

    if let Some(pos) = ecs.get_mut::<Position>(entity_4) {
        pos.test = 4;
    };

    ecs.remove::<Position>(entity_2);
    ecs.remove::<Position>(entity_0);

    if let Some(pos) = ecs.get::<Position>(entity_4) {
        assert_eq!(pos.test, 4);
    } else {
        panic!()
    }

    ecs.remove::<Position>(entity_4);

    if let Some(pos) = ecs.get::<Position>(entity_3) {
        assert_eq!(pos.test, 3);
    } else {
        panic!()
    }

    ecs.remove::<Position>(entity_3);

    assert_eq!(ecs.iter::<Position>().count(), 0)
}
